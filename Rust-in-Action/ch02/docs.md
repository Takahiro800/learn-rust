# 2.2
- 文字列にはダブルクオートを使う。シングルクオートを使うのは `char`という別の型

## 2.6 参照を使う
- リスト2-10

```rust
fn main() {
    let a = 42;
    let r = &a;
    let b = a + *r;

    println!("a + a = {}", b);
}
```

参照は参照演算子(&)によって作られ、参照を介したアクセスはでリファレンス演算子(*)によって行われる。
この２つの演算子は、オペランドを１つしか取らない単項演算子。

**参照**は、他のある値を、アドレスによって参照するあたい。ある意味では安価なコピーだが、本当に複製するのではなく、アドレスをメモリに保存する。データを取り出す必要が生じたら、デリファレンス(dereference)で変数を作ることができる

## 2.8 より高度な関数定義
```rust:2-13｜明示的なライフタイム注釈を持つ関数シグネイチャ
fn add_with_lifetimes<'a, 'b>(i: &'a i32, j: &'b i32) -> i32 {
	*i + *j
}
```
- `<'a, 'b>`は、add_with_lifetimes()をスコープとする２つのライフタイム変数、`'a`,''b'を宣言している。これらは「ライフタイムa」などと呼ばれる
- `i: &'a i32`は、ライフタイム変数`'a`を、iのライフタイムに束縛する。つまり、iは`ライフタイムaを持つ、i32型への参照`。